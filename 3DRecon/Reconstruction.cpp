// This file generated by ngrestcg
// For more information, please visit: https://github.com/loentar/ngrest

#include "Reconstruction.h"
#include <iostream>
#include "BasicFunction.h"
#include <iomanip>
#include"CRPCBased3DReconstruction.h"
#include "PointCloud2DEM.h"
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <get_cfg.h>
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

int _sysmkdir(const std::string& dir)
{
    int ret = mkdir(dir.c_str(), S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH);
    if (ret && errno == EEXIST)
    {
        printf("dir[%s] already exist.\n",dir.c_str());
    }
    else if (ret)
    {
        printf("create dir[%s] error: %d %s\n" ,dir.c_str(),ret ,strerror(errno));
        return -1;
    }
    else
    {
        printf("create dir[%s] success.\n", dir.c_str());
    }
    return 0;
}

std::string __getParentDir(const std::string& dir)
{
    std::string pdir = dir;
    if(pdir.length() < 1 || (pdir[0] != '/')){
        return "";
    }
    while(pdir.length() > 1 && (pdir[pdir.length() -1] == '/')) pdir = pdir.substr(0,pdir.length() -1);

    pdir = pdir.substr(0,pdir.find_last_of('/'));
    return pdir;
}

int _sysmkdirs(const std::string& dir)
{
    int ret = 0;
    if(dir.empty())
        return -1;
    std::string pdir;
    if((ret = _sysmkdir(dir)) == -1){
        pdir = __getParentDir(dir);
        if((ret = _sysmkdirs(pdir)) == 0){
            ret = _sysmkdirs(dir);
        }
    }
    return ret;
}


std::string Reconstruction::Reconstruction3D(std::string imgListFile,std::string uSer,std::string tIme,   std::string intMaxParallax,std::string 
                                intMinParallax, std::string intRowGridSize,std::string intColGridSize,std::string floatProjErrorThreshold,std::string floatDenoisingPara)
{
    //对json文件处理
    // 1.读取文件流为string
    std::ifstream f{imgListFile};
    std::stringstream ss;
    ss << f.rdbuf();
    auto data = ss.str();
    // 2.去掉前后括号

    string imgPaths_Block=data.substr(1,data.length());
    std::vector<string>  imgPaths_tmp;
    BasicFunction::Stringsplit(imgPaths_Block,"]",imgPaths_tmp);
    std::string imgPaths=imgPaths_tmp[0];
    // 3.以","分割整个字符串为vector
    std::vector<string>  imgPathVec;
    BasicFunction::Stringsplit(imgPaths,",",imgPathVec);

    // 4.去除引号，输出看看有没有问题
    for(int i=0;i<imgPathVec.size();i++)
    {
        imgPathVec[i]=imgPathVec[i].substr(1,imgPathVec[i].length()-2);
        std::cout<<imgPathVec[i]<<std::endl;
    }




    //写出的反馈信息
    std::string _Info1="{\"code\":\"200\", ";
        //工程目录
    map<string, string> m;
    const int MAX_LENGTH = 512;
    char buffer[MAX_LENGTH];
    getcwd(buffer, 512);
    std::string current_path = buffer;
    std::cout<<current_path<<endl;

    ReadConfig(current_path + "/utils/application_platform.cfg", m);
    std::string key = "root path";
    std::string root_path = m[key];

    std::string projectPath=root_path+"/"+uSer+"/Reconstruction3D/"+tIme;

    std::string _Info2 = "\"task path\":\"" + projectPath + "\", ";

	pid_t pid = fork();
	int childpid;
	if(pid == 0)
	{

		//创建日志文件
		childpid=getpid();
    
		std::string StartMessage=to_string(childpid)+",start";
		std::string RunningStateMsg=BasicFunction::Convert2Json_new(200,"3DReconstruction is running",0,"false");

        if(_sysmkdirs(projectPath)!=0)
        {
            cout<<"failed when create folder"<<endl;
            return "failed";
        };


		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",StartMessage);
		BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);

		//运行功能
        std::cout<<StartMessage<<std::endl;  

        int MaxParallax=std::stoi(intMaxParallax);
        int MinParallax=std::stoi(intMinParallax);
        int RowGridSize=std::stoi(intRowGridSize);
        int ColGridSize=std::stoi(intColGridSize);
        float ProjErrorThreshold=std::stof(floatProjErrorThreshold);
        float DenoisingPara=std::stof(floatDenoisingPara);


        bool ok=true;
        if(MaxParallax<0 || MaxParallax>128)
        {

            ok=false;
            std::cout<<"\nThe range of MaxParallax should be 0 to 128.\n";
        }
        if(MinParallax<-128 || MinParallax>0)
        {

            ok=false;
            std::cout<<"The range of MinParallax should be -128 to 0.\n";
        }
        if(RowGridSize<1 || RowGridSize>100 || ColGridSize<1 || ColGridSize>100 )
        {

            ok=false;
            std::cout<<"The range of RowGridSize and ColGridSize should be 1 to 100.\n";
        }
        if(ProjErrorThreshold<1 || ProjErrorThreshold>20 )
        {

            ok=false;
            std::cout<<"The range of ProjErrorThreshold should be 1 to 20.\n";
        }
        if(DenoisingPara<1 || DenoisingPara>10 )
        {

            ok=false;
            std::cout<<"The range of DenoisingPara should be 1 to 10.\n";
        }
        





        if(ok)
        {
            
            CRPCBased3DReconstruction func;
            func.SetParams(imgPathVec,MinParallax,MaxParallax,RowGridSize,ColGridSize,ProjErrorThreshold,DenoisingPara);

            // std::string pointCloudSavePath=projectPath+"/pointCould.txt";
            func.run(projectPath);

            RunningStateMsg=BasicFunction::Convert2Json_new(200,"3DReconstruction is done",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;

         
        }
        else{
            RunningStateMsg=BasicFunction::Convert2Json_new(500,"3DReconstruction failed",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;
        }




		std::string EndMessage=to_string(childpid)+",end";
		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",EndMessage);
		abort();
	
	}
	else
	{
		sleep(3);
	}
	std::string _Info3="\"childpid\":\""+std::to_string((pid))+"\"}";
    return _Info1+_Info2+_Info3;

}


std::string Reconstruction::CSF_Filter(std::string pointCloudPath,std::string uSer,std::string tIme,std::string floatCSF_Size,std::string floatClassificationThreshold)
{
    
    //反馈信息1
    std::string _Info1="{\"code\":\"200\", ";

    //工程目录
    map<string, string> m;
    const int MAX_LENGTH = 512;
    char buffer[MAX_LENGTH];
    getcwd(buffer, 512);
    std::string current_path = buffer;
    std::cout<<current_path<<endl;

    ReadConfig(current_path + "/utils/application_platform.cfg", m);
    std::string key = "root path";
    std::string root_path = m[key];

    std::string projectPath=root_path+"/"+uSer+"/Reconstruction3D/"+tIme;

    //反馈信息2
    std::string _Info2 = "\"task path\":\"" + projectPath + "\", ";

    //开启子进程
	pid_t pid = fork();
	int childpid;
	if(pid == 0)
	{

		
		childpid=getpid();


		std::string StartMessage=to_string(childpid)+",start";
		std::string RunningStateMsg=BasicFunction::Convert2Json_new(200,"CSF_Filter is running",0.0,"false");
       
       //创建工程目录
        if(_sysmkdirs(projectPath)!=0)
        {
            cout<<"failed when create folder"<<endl;
            return "failed";
        };

        //创建日志文件
		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",StartMessage);
		BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);

		//运行功能

        std::cout<<StartMessage<<std::endl;

        float CSF_Size=std::stof(floatCSF_Size);
        float ClassificationThreshold=std::stof(floatClassificationThreshold);


        bool ok=true;
        if(CSF_Size<0.1 || CSF_Size>100 )
        {

            ok=false;
            std::cout<<"The range of CSF_Size should be 0.1 to 100.\n";
        }
        if(ClassificationThreshold<0.1 ||ClassificationThreshold>10 )
        {

            ok=false;
            std::cout<<"The range of ClassificationThreshold should be 0.1 to 10.\n";
        }
    

        if(ok)
        {
            PointCloud2DEM::Points2GroundPoints(pointCloudPath,projectPath,true, CSF_Size, ClassificationThreshold);
            RunningStateMsg=BasicFunction::Convert2Json_new(200,"CSF_Filter is done",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;
            // return BasicFunction::Convert2Json(200,"done",1,"CSF");
        }
        else{
            RunningStateMsg=BasicFunction::Convert2Json_new(500,"CSF_Filter failed",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;
            // return BasicFunction::Convert2Json(500,"Fail",1,"CSF");
        }


        std::string EndMessage=to_string(childpid)+",end";
		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",EndMessage);
        abort();
	
	}
	else
	{
		sleep(3);
	}
	std::string _Info3="\"childpid\":\""+std::to_string((pid))+"\"}";
    return _Info1+_Info2+_Info3;
}

std::string Reconstruction::DEM_Interpolation(std::string groundPointCloudPath,std::string uSer,std::string tIme, 
                            std::string floatGridSize)
{
    //写出的反馈信息
    std::string _Info1="{\"code\":\"200\", ";
    //工程目录
    map<string, string> m;
    const int MAX_LENGTH = 512;
    char buffer[MAX_LENGTH];
    getcwd(buffer, 512);
    std::string current_path = buffer;
    std::cout<<current_path<<endl;

    ReadConfig(current_path + "/utils/application_platform.cfg", m);
    std::string key = "root path";
    std::string root_path = m[key];

    std::string projectPath=root_path+"/"+uSer+"/Reconstruction3D/"+tIme;

    std::string _Info2 = "\"task path\":\"" + projectPath + "\", ";


	pid_t pid = fork();
	int childpid;
	if(pid == 0)
	{

		//创建日志文件
		childpid=getpid();

		std::string StartMessage=to_string(childpid)+",start";
		std::string RunningStateMsg=BasicFunction::Convert2Json_new(200,"DEM_Interpolation is running",0.,"false");

        
          if(_sysmkdirs(projectPath)!=0)
        {
            cout<<"failed when create folder"<<endl;
            return "failed";
        };


		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",StartMessage);
		BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);


		//运行功能
        std::cout<<StartMessage<<std::endl;

        float GridSize=std::stof(floatGridSize);
        bool ok=true;
        if(GridSize<0.01 ||GridSize>100 )
        {

            ok=false;
            std::cout<<"The range of GridSize should be 0.01 to 100.\n";
        }


        
        if(ok)
        {
            PointCloud2DEM::GroundPoints2DEM(groundPointCloudPath, projectPath, GridSize);
            RunningStateMsg=BasicFunction::Convert2Json_new(200,"DEM_Interpolation is done",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;
            // return BasicFunction::Convert2Json(200,"done",1,"DEM_Interpolation");
        }
        else{
            RunningStateMsg=BasicFunction::Convert2Json_new(500,"DEM_Interpolation failed",1,"true");
            BasicFunction::Write2Text(projectPath+"/RunningState_Log.txt",RunningStateMsg);
            std::cout<<RunningStateMsg<<std::endl;
            // return BasicFunction::Convert2Json(500,"Fail",1,"DEM_Interpolation");
        }

        std::string EndMessage=to_string(childpid)+",end";
		BasicFunction::Write2Text(projectPath+"/IsEnd.txt",EndMessage);
        abort();
	
	}
	else
	{
		sleep(3);
	}
	std::string _Info3="\"childpid\":\""+std::to_string((pid))+"\"}";
    return _Info1+_Info2+_Info3;
    
}




std::string Reconstruction::GetTaskState_Service(std::string ProjectPath, std::string childpid)
{
	
	//读取日志文件，判断是否结束
 	std::vector<std::string> InfoList_Raw;
	BasicFunction::ReadImageNames(ProjectPath+"/IsEnd.txt",InfoList_Raw);
	std::vector<std::string> InfoList;
 	BasicFunction::Stringsplit(InfoList_Raw[0],",",InfoList);

    if(childpid == InfoList[0])
	{
		std::vector<std::string> InfoList;
		if(BasicFunction::ReadImageNames(ProjectPath + "/RunningState_Log.txt",InfoList))
		{
			
			return InfoList[InfoList.size()-1];
		}
		else
		{
			return "Can not find log file";
		}

	}
	else
	{
		std::string Info =BasicFunction::Convert2Json(500,"The given childpid does not match!");
 		return Info;

	}
}


std::string Reconstruction::CancelCurrentWork_Service(std::string text)
{
	int childpid =std::stoi(text);
	int retval = kill(childpid, SIGKILL);  //发送SIGKILL给子进程，要求其停止运行
    string _Info = "";        
	if (!retval)   //判断是否发生信号
	{
		_Info = BasicFunction::Convert2Json(200,"process was killed");
		
	}
	else
	{
		_Info = BasicFunction::Convert2Json(500,"Can not kill process");
	}

	
	return _Info;
		
}

